# Lessons 1 and 2. Analysing Windows Malicious Programs

## Understanding Windows API

In simple terms, it contains a variety of tools (functions) that developers can use to make the Windows operating system (OS) perform tasks. These tasks might include creating windows, handling user input, displaying text or images on the screen, managing files, and much more.

We can think of the Windows API as a middleman between the software and the hardware. When a developer wants to write a program that runs on Windows, they use these API functions to tell the operating system what to do, rather than directly interfacing with the hardware. This abstraction simplifies programming by hiding the complexity of dealing with hardware details directly.

###  Windows API and Malware Analysis

When it comes to malware analysis, understanding the Windows API is crucial for a few reasons:

1. **Behavior Analysis**: Malware, like any other software, needs to interact with the operating system to carry out its malicious activities. It might use the Windows API to create files, send data over the internet (networking API), execute programs (DLLs), or modify system settings (windows registry). By knowing what various API functions do, analysts can better understand what a piece of malware is trying to achieve when they see it calling those functions.

2. **Signature Creation**: Security experts often create signatures or rules that help identify malicious activities based on API calls (callbacks). For example, if a piece of malware uses a specific sequence of API calls to hide itself from the user, a signature detecting these API calls can be created to alert analysts or antivirus software about potential threats.

3. **Reverse Engineering**: Malware often tries to obscure its true purpose through techniques like packing or encryption. Analysts use their knowledge of API calls to reverse engineer malware and understand its structure and functionality. By observing which APIs are called, they can infer the malware’s capabilities and intentions.

4. **Automation Tools**: Tools used in malware analysis, such as debuggers or automated analysis platforms, often hook into these API calls to monitor the behavior of a suspect program in a controlled environment. This allows the tools to log what the program is doing without altering its code directly.

### Hungarian Notation

Hungarian Notation is a naming convention used in programming, where the name of a variable indicates its type or intended use. It was popularized by Charles Simonyi, a Microsoft developer originally from Hungary, hence the name "_Hungarian_." In this system, variable names are prefixed with letters that suggest their type. For example, `szName` might be used to indicate a "zero-terminated string" (where 'sz' stands for "string zero").

#### Why Windows API Uses Hungarian Notation?

1. **Type Safety**: Before more modern programming languages enforced strict type-checking, Hungarian Notation provided a manual way to keep track of variable types. This helped prevent errors where variables of one type were mistakenly used as if they were another type.

2. **Code Readability**: When dealing with a large codebase like that of the Windows API, having variable names that include type information can make the code easier to understand quickly. This is especially helpful in an environment where multiple developers are working on the same code.

3. **Historical Context**: The notation became a standard in early Windows development and has continued due to legacy reasons. It was a part of the developer culture at Microsoft when the Windows APIs were being developed.

**In the context of malware analysis, Hungarian Notation can play a role in a few ways**:

- [x] **Understanding Code**: When analyzing malware, if the malware is written using the Windows API, familiarity with Hungarian Notation can help analysts quickly understand what type of data a particular variable holds. This can speed up the analysis process, as the analyst can more easily interpret the malware’s code.

- [x] **Consistency with Industry Standards**: Since many legitimate applications and older pieces of malware use the Windows API and, by extension, Hungarian Notation, understanding this convention allows analysts to navigate through a wide range of software efficiently.

- [x] **Pattern Recognition**: Malware often mimics legitimate applications to avoid detection. Recognizing naming conventions such as Hungarian Notation can help in identifying suspicious patterns in ostensibly benign code. If malware modifies existing code on a system, discrepancies in naming conventions can be a clue to its presence.

| Type  | Prefix | Description                                       |
|-------|--------|---------------------------------------------------|
| WORD  | w      | A 16-bit unsigned value                           |
| DWORD | dw     | A 32-bit unsigned value (double-WORD)             |
| Handle| H      | A reference to an object, e.g., HModule, HInstance|
| Pointer| LP    | A pointer to a type, e.g., LPByte, LPCSTR         |
| Callback | -    | Function called by Windows API, e.g., status updates |

### Key Windows API Components

Knowing how different aspects of the Windows API interact gives analysts a broader understanding of how applications (malicious or otherwise) operate on a Windows system. This is critical for identifying abnormal behaviors that might indicate malicious intent. Each component can be a target or tool for malware. For instance, if malware manipulates file system functions, it might be trying to steal or corrupt data. If it uses network APIs, it might be communicating with an attacker.

Post-attack analysis often involves studying how malware interacted with these components to reconstruct the event and understand the breach extent. This knowledge is vital for improving security measures and recovering from attacks.

| **API Component**       | **Purpose**                                                                                          | **Relation to Malware Analysis**                                                                                      |
|--------------------------|------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------|
| **File System Functions** | Handle operations on files and directories.                                                          | Malware uses these to hide, spread, or steal data. Monitoring file operations can identify malicious activities.      |
| **Networking API**         | Facilitate data transmission over networks.                                                          | Utilized by malware for command and control, data exfiltration, and spreading. Network activity is a key indicator.  |
| **Windows Registry**       | Store configuration settings and options.                                                            | Malware manipulates registry for persistence and configuration. Monitoring changes can reveal malware activities.    |
| **DLLs (Dynamic Link Libraries)** | Share code and resources among multiple applications.                                        | Malware may inject code into DLLs or masquerade as legitimate DLLs to execute malicious activities stealthily.       |
| **Processes and Threads**  | Execute and manage running applications; threads allow concurrent operations within the same process. | Malware may spawn processes or threads to perform tasks secretly. Analyzing these can expose hidden malware operations.|
| **Mutexes (Mutual Exclusions)** | Prevent multiple threads from accessing the same resource at the same time.                         | Malware uses mutexes to avoid running multiple instances or signal presence to other malware. Detecting mutexes can help identify and isolate malware instances.             |

#### 1. File System Functions
The file system functions in the Windows API allow programs to interact with files and directories on a computer. This includes creating, reading, writing, and deleting files, as well as creating or removing directories. Essentially, these functions let software organize and manage the data stored on a hard drive, much like how you might manage files and folders manually through File Explorer.

Malware uses file system functions to carry out harmful activities without the user's knowledge. This can include:

- **Hiding files**: Malware might create hidden or system files that are not easily visible to the user.
- **Spreading**: Malware may copy itself to different directories or drives.
- **Data theft**: Malware can search for and exfiltrate specific files containing sensitive data.

Understanding how malware interacts with the file system can help in detecting suspicious file activities and aid in forensic analysis.

#### Special Files

Special files in Windows include system files and hidden files, among others. These are not typical user data files; instead, they are used by the operating system to perform its functions. Examples include system configuration files, files containing system state information, or files used by the OS for logging and temporary storage.

* **Shared files** are files that can be accessed by multiple programs simultaneously. This often includes dynamic link libraries (DLLs), which contain code and data that multiple applications can use concurrently. Shared files are a crucial part of how applications reuse code and interact with the operating system. Often, shared files are special files themselves. 

    * Malware often targets special or shared files to execute its code across multiple programs or to embed itself within system processes to evade detection. By modifying or replacing these files, malware can gain persistence or control over system operations.

* **Alternate Data Streams (ADS)** allow multiple data streams to be associated with a filesystem object. This feature is specific to NTFS (New Technology File System) used by Windows. ADS can be used to store metadata or additional files invisibly alongside a visible file without affecting the file's functionality. This can include storing thumbnails for image files or storing additional authoring information.

    * Malware can use ADS to hide its code or data within the file system. Since data stored in ADS is not visible in standard file browsers and requires specific commands to detect, it provides a stealthy method for malware to persist on a system without being easily discovered. 

* **Namespaces** provide a way to access a wide range of resources, including special and shared files, using a hierarchical naming system. For instance, in Windows, you can access many special files (like system devices) through the "Global??" namespace, which is part of the NT (lowest level) namespace. Namespaces also help in categorizing and accessing files that might contain alternate data streams. Since namespaces often represent paths or resource locators in a structured format, they can be used to point to specific data streams associated with a file.

    * Malware can manipulate namespaces to redirect applications or system operations to malicious resources. For example, a malware could redirect a namespace used for loading a system DLL to a malicious DLL, effectively hijacking the functionality expected by applications.


#### 2. Networking API
The networking API in Windows allows programs to communicate over a network. This includes sending and receiving data over the internet, connecting to remote servers, and hosting services that others can connect to. Using these functions, programs can access web pages, download files, or exchange information with other systems globally.

Networking APIs are critical in the context of malware for several reasons:

- **Command and Control (C&C)**: Many types of malware communicate with a remote server for instructions, known as command and control servers.
- **Data exfiltration**: Malware can use these APIs to send stolen data to an attacker.
- **Spreading**: Malware may use network APIs to spread to other systems across a network.

Analyzing network activity generated by suspicious programs can help identify malware, especially if the programs are communicating with known malicious servers or using unusual network protocols.

#### Common Networking API Functions

**Berkeley-Compatible Sockets:**
| Function | Description |
|----------|-------------|
| `socket()` | Creates a socket for network communication. |
| `bind()` | Associates the socket with a specific local address and port. |
| `listen()` | Prepares the socket to accept incoming connections. |
| `accept()` | Waits for and accepts an incoming connection. |
| `connect()` | Establishes a connection to a remote socket. |
| `send()` | Sends data to a connected socket. |
| `recv()` | Receives data from a connected socket. |

##### Socket Syntax

`socket (int af, int type, int protocol)`

- **`af` (Address Family):** Typically set to 2, indicating the IPv4 address family.
- **`type`:** Usually 1, indicating a TCP socket.
- **`protocol`:** Often set to 0, allowing the system to select the appropriate protocol automatically.

##### Server and Client Networking
- **Server Side:** Maintains a socket waiting for connections; uses `socket`, `bind`, `listen`, `accept`.
- **Client Side:** Initiates connections using `socket` and `connect`.

##### WinINet API

- **Library:** `Wininet.dll` implementing high-level protocols like HTTP and FTP, facilitating simpler network communications.
- **Functions:** `InternetOpen`, `InternetOpenUrl`, `InternetReadFile` — typically used by malware to establish and maintain connections to remote servers, often to download further malicious payloads or receive commands.

**Key Functions:**
| Function | Description |
|----------|-------------|
| `InternetOpen` | Initializes a connection to the Internet. |
| `InternetOpenUrl` | Connects to a specific URL, which can be an HTTP page or an FTP site. |
| `InternetReadFile` | Reads data from a file downloaded from the Internet. |

#### 3. **Windows Registry**
The Windows Registry is a database used by Windows to store configuration information. Both Windows itself and installed applications use the registry to save settings and options. The registry is organized hierarchically, similar to a file system, with keys and values that can be read and modified by programs. This allows software to remember settings between sessions and also lets different programs interact with or alter each other's settings if needed.

The Windows Registry is often used by malware to achieve persistence and stealth:

- **Persistence**: Malware often adds entries to the Windows Registry to ensure it is reactivated every time the computer starts.
- **Configuration**: Malware can store configurations in the registry to maintain state or preferences between sessions.
- **Stealth**: Changes to registry settings can help malware hide its presence from both users and security software.

Monitoring registry modifications can therefore be a powerful way to detect and analyze malware, particularly those aspects related to its persistence mechanisms and configuration changes.

##### Registry Hives
A hive is a top-level data structure that stores configuration settings for different aspects of the system and user environment. The most commonly used hives include:

1. **HKEY_LOCAL_MACHINE (HKLM)**: Stores settings that affect the entire system, including all users and services.
2. **HKEY_CURRENT_USER (HKCU)**: Contains configuration information specific to the currently logged-in user.
3. **HKEY_CLASSES_ROOT (HKCR)**: Aggregates configuration information related to applications and file type associations.
4. **HKEY_USERS (HKU)**: Stores settings for all user profiles on the machine.
5. **HKEY_CURRENT_CONFIG (HKCC)**: Contains information about the hardware profile that is used by the system at system startup.

Malware can create or modify existing registry keys to run its code automatically upon system startup, usually by adding entries to `HKLM\Software\Microsoft\Windows\CurrentVersion\Run` or `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`.

##### Types of Registry Values
- **String Value (REG_SZ)**: Stores text as a sequence of characters.
- **Binary Value (REG_BINARY)**: Stores data in raw binary format.
- **DWORD (32-bit) Value (REG_DWORD)**: Stores a 32-bit number.
- **QWORD (64-bit) Value (REG_QWORD)**: Stores a 64-bit number.
- **Multi-String Value (REG_MULTI_SZ)**: Stores multiple strings, separated by NULL characters.
- **Expandable String Value (REG_EXPAND_SZ)**: Stores variables that can be expanded to other values when accessed by the system.

#### 4. DLLs (Dynamic Link Libraries)

DLLs are files that contain code and data that can be used by multiple programs at the same time. Think of them as a library where programs can borrow code to perform common tasks like displaying a window or working with files. Using DLLs helps make program files smaller and saves memory because the code is shared among multiple applications.

Malware often injects malicious code into existing DLLs to execute harmful activities covertly. Analyzing DLLs that are loaded by programs can help identify unauthorized modifications or suspicious activities. For example, malware DLLs usually have more exports than imports.

#### 5. Processes

A process is an instance of a program running on a computer. Each process provides the resources needed to execute a program. A process has a private set of resources such as memory, and it operates independently of other processes. Processes are isolated by the operating system (OS) to prevent them from interfering with one another, which helps maintain system stability.

* Malware can create new processes to execute malicious tasks. Monitoring process creation and the attributes of processes can help detect and analyze potential threats.

* A **thread** is a sequence of executable commands within a process. A process can have multiple threads running code concurrently within the same application, sharing the process's resources. Threads allow a program to perform multiple operations at the same time, such as typing text in one part of a program while loading a file in another.
    * Malware often uses threads to perform multiple tasks simultaneously and discreetly. Detecting unusual thread activity within processes can be a clue to malicious operations.


#### 6. Mutexes

A mutex is a program object that allows multiple program threads to share the same resource, such as file access, but not simultaneously. When a thread locks a mutex, it gains exclusive access to a resource. This prevents other threads from accessing the resource until the mutex is unlocked. It's like having a key to a room that prevents others from entering while you're inside.

* Mutexes are used to avoid the problem of resource conflicts between threads and are managed through the Windows API.
* Malware uses mutexes to avoid running multiple instances of itself, which can be a sign of infection. Identifying unique or suspicious mutex names can help detect specific strains of malware.


### Kernel Mode vs. User Mode

Windows operating systems operate using two primary modes to manage how programs and processes interact with the hardware: Kernel Mode and User Mode. 

* **Kernel Mode**: is where the operating system's core components run and have unrestricted access to the hardware. This mode runs the most trusted code, which includes the operating system kernel itself and its drivers.
    * Because it can directly interact with the system hardware, Kernel Mode has the highest level of privileges. Code running in this mode can execute any CPU instruction and reference any memory address.
    * Kernel Mode is primarily used for low-level, trusted functions like managing memory, process and thread management, and direct hardware operations.

* **User Mode**: is a restricted mode where applications are run. This mode limits access to system hardware and core system functions. Applications running in this mode must communicate with the operating system (OS) to perform more advanced tasks like reading or writing to disk or sending and receiving network data.
    * User Mode has limited privileges to prevent applications from directly modifying system data or hardware settings, which helps maintain system stability and security.
    * The primary purpose of User Mode is to provide an environment where applications can run safely without affecting the critical components of the operating system.

The distinction between Kernel Mode and User Mode is extremely relevant in malware analysis for several reasons:

1. **Attack Surface**: Malware that operates in Kernel Mode can control almost anything on a system, making it particularly dangerous. Such malware is harder to detect and can disable security measures directly. Detecting and analyzing Kernel Mode malware requires specialized tools and deeper system knowledge.

2. **Damage Potential**: Malware in Kernel Mode can cause more severe damage, including system corruption, undetectable spying, and total control over system resources. In contrast, User Mode malware is generally less powerful but more common and can be easier to manage and remove.

3. **Defense Strategies**: Security strategies differ based on the mode. Kernel Mode security involves securing the boot process and ensuring integrity of drivers and the kernel itself. User Mode security focuses more on managing application permissions, sandboxing applications, and monitoring behavior to prevent exploitation.

#### Native API

The Native API refers to a set of system-level functions used by Windows operating systems, particularly within the `Ntdll.dll` library. This API serves as an interface between user-mode applications and the kernel.

- **Lower-Level Access**: Provides functionalities that are closer to the kernel, allowing for operations that are not possible in user mode alone.
- **Separation from User Applications**: This separation ensures that changes to the kernel do not necessarily affect applications as the Native API acts as a stable interface, even if underlying kernel implementations change. While the Native API primarily operates in Kernel Mode, it also exposes a subset of its functionality to User Mode via the NTDLL.DLL. This allows User Mode processes to make use of low-level system functions indirectly, which are necessary for operations that higher-level APIs, like the Win32 API, rely on.

Malware often uses Native API calls to manipulate low-level system functions in ways that can be difficult to detect with tools that monitor higher-level API calls (like those in the Win32 API). For example, malware might use Native API functions to manipulate processes and memory, hide its presence, or load malicious drivers.

* The use of the Native API can be a sign of more sophisticated malware that understands the deeper workings of Windows internals. This can include rootkits and kernel exploits, which are especially dangerous and challenging to detect and remove.

#### Examples of Native API Functions
- **System Queries**: Functions like `NtQuerySystemInformation` and `NtQueryInformationProcess` provide deep insights into system operations, useful for surveillance and control.
- **NtContinue**: Particularly noted for its use in sophisticated malware, this function is used to manipulate the execution flow after handling exceptions, enabling malware to resume operations seamlessly after disruptive events.
- **Memory Management**: Functions like `NtAllocateVirtualMemory` and `NtFreeVirtualMemory` are crucial for managing memory directly, which can be used for hiding malware payloads in memory spaces managed outside typical application controls.
